import Foundation
import Capacitor
import SwiftUI
import UIKit

@objc(ChatOverlayPlugin)
public class ChatOverlayPlugin: CAPPlugin {
    
    private var overlayHostingController: UIHostingController<NativeChatOverlay>?
    private var isOverlayVisible = false
    private var isOverlayExpanded = false
    
    public override func load() {
        NSLog("🚀 ChatOverlayPlugin 已加载!")
    }
    
    @objc func show(_ call: CAPPluginCall) {
        NSLog("📱 ChatOverlayPlugin: show方法被调用")
        call.resolve(["status": "success", "message": "ChatOverlay插件正常工作"])
    }
    
    @objc func hide(_ call: CAPPluginCall) {
        NSLog("📱 ChatOverlayPlugin: hide方法被调用")
        DispatchQueue.main.async {
            self.hideNativeOverlay()
            call.resolve()
        }
    }
    
    @objc func sendMessage(_ call: CAPPluginCall) {
        NSLog("📱 ChatOverlayPlugin: sendMessage方法被调用")
        let message = call.getString("message") ?? ""
        
        // 模拟AI响应
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.notifyListeners("messageReceived", data: [
                "response": "这是对'\(message)'的AI响应",
                "timestamp": Date().timeIntervalSince1970
            ])
        }
        
        call.resolve()
    }
    
    private func showNativeOverlay(isExpanded: Bool) {
        NSLog("📱 showNativeOverlay开始执行，isExpanded: \(isExpanded)")
        
        if overlayHostingController != nil {
            NSLog("📱 浮窗已存在，直接更新状态")
            isOverlayExpanded = isExpanded
            return
        }
        
        isOverlayExpanded = isExpanded
        
        let overlayView = NativeChatOverlay(
            isExpanded: .constant(isExpanded),
            onClose: { [weak self] in
                NSLog("📱 浮窗关闭回调被调用")
                self?.hideNativeOverlay()
                self?.notifyListeners("overlayStateChanged", data: ["isOpen": false])
            },
            onReopen: { [weak self] in
                NSLog("📱 重新打开浮窗回调被调用")
                self?.isOverlayExpanded = true
                self?.notifyListeners("overlayStateChanged", data: ["isOpen": true])
            },
            onFollowUpProcessed: { [weak self] in
                NSLog("📱 后续问题处理完成回调被调用")
                self?.notifyListeners("followUpProcessed", data: [:])
            }
        )
        
        let hostingController = UIHostingController(rootView: overlayView)
        hostingController.view.backgroundColor = UIColor.clear
        hostingController.modalPresentationStyle = .overFullScreen
        hostingController.modalTransitionStyle = .crossDissolve
        
        overlayHostingController = hostingController
        
        if let viewController = bridge?.viewController {
            NSLog("📱 开始present浮窗")
            viewController.present(hostingController, animated: true) { [weak self] in
                NSLog("📱 浮窗present完成")
                self?.isOverlayVisible = true
                self?.notifyListeners("overlayStateChanged", data: ["isOpen": true])
            }
        } else {
            NSLog("❌ viewController为nil")
        }
    }
    
    private func hideNativeOverlay() {
        guard let hostingController = overlayHostingController else { return }
        
        hostingController.dismiss(animated: true) { [weak self] in
            self?.overlayHostingController = nil
            self?.isOverlayVisible = false
            self?.notifyListeners("overlayStateChanged", data: ["isOpen": false])
        }
    }
    
    // 接收来自JavaScript的AI回复
    @objc func receiveAIResponse(_ call: CAPPluginCall) {
        let response = call.getString("response") ?? ""
        let timestamp = call.getDouble("timestamp") ?? Date().timeIntervalSince1970
        
        NSLog("📱 receiveAIResponse: \(response)")
        
        // 这里可以将AI回复传递给SwiftUI界面
        // 暂时通过回调通知界面更新
        self.notifyListeners("aiResponse", data: [
            "response": response,
            "timestamp": timestamp
        ])
        
        call.resolve()
    }
    
    // 从JavaScript端更新消息列表
    @objc func updateMessages(_ call: CAPPluginCall) {
        let messagesArray = call.getArray("messages", JSObject.self) ?? []
        NSLog("📱 updateMessages: 接收到\(messagesArray.count)条消息")
        
        DispatchQueue.main.async {
            self.updateOverlayMessages(messagesArray)
        }
        
        call.resolve()
    }
    
    // 设置对话标题 - 对应Web版本的conversationTitle功能
    @objc func setConversationTitle(_ call: CAPPluginCall) {
        let title = call.getString("title") ?? ""
        NSLog("📱 setConversationTitle: \(title)")
        
        DispatchQueue.main.async {
            self.updateOverlayConversationTitle(title)
        }
        
        call.resolve()
    }
    
    // 设置键盘高度 - 对应Web版本的键盘适配功能
    @objc func setKeyboardHeight(_ call: CAPPluginCall) {
        let height = call.getFloat("height") ?? 0.0
        NSLog("📱 setKeyboardHeight: \(height)")
        
        DispatchQueue.main.async {
            self.updateOverlayKeyboardHeight(CGFloat(height))
        }
        
        call.resolve()
    }
    
    // 设置视口高度 - 对应Web版本的视口适配
    @objc func setViewportHeight(_ call: CAPPluginCall) {
        let height = call.getFloat("height") ?? 0.0
        NSLog("📱 setViewportHeight: \(height)")
        
        DispatchQueue.main.async {
            self.updateOverlayViewportHeight(CGFloat(height))
        }
        
        call.resolve()
    }
    
    // 设置初始输入 - 对应Web版本的initialInput功能
    @objc func setInitialInput(_ call: CAPPluginCall) {
        let input = call.getString("input") ?? ""
        NSLog("📱 setInitialInput: \(input)")
        
        DispatchQueue.main.async {
            self.updateOverlayInitialInput(input)
        }
        
        call.resolve()
    }
    
    // 设置后续问题 - 对应Web版本的followUpQuestion功能
    @objc func setFollowUpQuestion(_ call: CAPPluginCall) {
        let question = call.getString("question") ?? ""
        NSLog("📱 setFollowUpQuestion: \(question)")
        
        DispatchQueue.main.async {
            self.updateOverlayFollowUpQuestion(question)
        }
        
        call.resolve()
    }
    
    // 更新SwiftUI界面的消息列表
    private func updateOverlayMessages(_ messages: [JSObject]) {
        guard let hostingController = overlayHostingController else { return }
        
        NSLog("📱 更新界面消息列表")
        
        // 通过事件通知的方式更新SwiftUI状态
        self.notifyListeners("messagesUpdated", data: [
            "messages": messages,
            "count": messages.count
        ])
    }
    
    // 更新SwiftUI界面的对话标题
    private func updateOverlayConversationTitle(_ title: String) {
        self.notifyListeners("conversationTitleChanged", data: [
            "title": title
        ])
    }
    
    // 更新SwiftUI界面的键盘高度
    private func updateOverlayKeyboardHeight(_ height: CGFloat) {
        self.notifyListeners("keyboardHeightChanged", data: [
            "height": height
        ])
    }
    
    // 更新SwiftUI界面的视口高度
    private func updateOverlayViewportHeight(_ height: CGFloat) {
        self.notifyListeners("viewportHeightChanged", data: [
            "height": height
        ])
    }
    
    // 更新SwiftUI界面的初始输入
    private func updateOverlayInitialInput(_ input: String) {
        self.notifyListeners("initialInputChanged", data: [
            "input": input
        ])
    }
    
    // 更新SwiftUI界面的后续问题
    private func updateOverlayFollowUpQuestion(_ question: String) {
        self.notifyListeners("followUpQuestionChanged", data: [
            "question": question
        ])
    }
    
    // 设置加载状态
    @objc func setLoading(_ call: CAPPluginCall) {
        let loading = call.getBool("loading") ?? false
        NSLog("📱 setLoading: \(loading)")
        
        DispatchQueue.main.async {
            self.setOverlayLoading(loading)
        }
        
        call.resolve()
    }
    
    // 设置SwiftUI界面的加载状态
    private func setOverlayLoading(_ loading: Bool) {
        guard let hostingController = overlayHostingController else { return }
        
        NSLog("📱 设置界面加载状态: \(loading)")
        
        self.notifyListeners("loadingStateChanged", data: [
            "loading": loading
        ])
    }
}

// 浮窗状态管理类 - 用于在Swift和JavaScript之间同步状态
class OverlayState: ObservableObject {
    @Published var messages: [ChatMessage] = []
    @Published var isLoading = false
    @Published var conversationTitle = ""
    @Published var keyboardHeight: CGFloat = 0
    @Published var viewportHeight: CGFloat = UIScreen.main.bounds.height
    @Published var initialInput = ""
    @Published var followUpQuestion = ""
    @Published var isKeyboardOpen = false
}