#语言
总是用中文回复

#背景
当前的项目，我们正在执行原版的capacitor react项目，向 starO这个纯swift原生项目的迁移。你需要明确，我们当前的所有修改都是针对starO进行的修改，react版本仅作参考

#原则
我会在下方的任务区域标注需要执行的任务以及完成的任务，如果包含<完成>，则表示已经完成，请忽略，每次仅执行未包含<完成>的任务；如果有多个任务执行文档最下方的任务。

#执行过程
完成任务后将执行过的任务标记上<完成>，并且新建一个标题，命名为任务n，n是上一个完成的任务+1。

#任务1<完成>
现在我发现我们starO项目中，首页是可以上下滑动的，让我们取消这个可以上下滑动的特性，会显得很不稳定

#任务2<完成>
刚才的取消上下滑动引入了一些问题，首先首页的点击动效不需要，现在点击动效导致了左右滑动的触发阈值变高了，所以导致了左右滑动不够灵敏；其次是左右pane出现的时候，在左右pane的页面上进行左滑、右滑，pane不会出现动效上的左右变化，这会又不跟手的感觉。请根据我的描述，确认是否有这些问题，并且进行问题的定位和解决。

#任务3 <完成>
现在我发现我们在修复过程中，对话的api调用又失效了，无法调用大模型回复，参考d493e1f07f2859f00c1b626cbb871e8bc0a0077e，请根据这个commit，确认是否有这个问题，并且进行问题的定位和解决。

#任务4 <完成>
现在我们在staro中尝试修复输入框弹起的时候吧对话框也顶起，然后对话框吧对话气泡顶起，现在已经部分实现了，但在有些场景下没实现，现在当我们在首次进入的时候，此时浮窗还未出现，这时候我们输入文字，点击发送，此时应该弹起浮窗，同时因为键盘和输入框还在弹起状态，那么气泡出现后也应该被顶起来，现在这种状态下气泡还是我输入框遮挡的，这暴露了一个问题，我们只是在某些条件下做了这件事情，而不是把这不遮挡，被顶起来的逻辑变成一个非常强硬的规则，在任何情况下都应该输入框把气泡顶起，气泡的空间就不应该能够走道输入框下方。

【修复说明】
- 在原生 ChatOverlay 展开态：新增强制规则，基于最新 InputDrawer 实际位置，实时调整消息列表底部内边距，确保气泡永不被输入框遮挡。
- 关键改动：
  - `StarO/StarO/InputDrawerManager.swift`: 记录最新的 `actualBottomSpace` 到 `InputDrawerState.shared` 并持续广播。
  - `StarO/StarO/ChatOverlayManager.swift`: 在 `viewDidAppear` 和每次 `updateForState(.expanded)` 后，读取最新位置并调用 `adjustExpandedContentInset`。

#任务5 <完成>
现在我们再尝试修复staro中对话框遮挡问题，现在我们在staro中尝试修复输入框弹起的时候吧对话框也顶起，然后对话框吧对话气泡顶起，现在已经部分实现了，但在有些场景下没实现，现在当我们在首次进入的时候，此时浮窗还未出现，这时候我们输入文字，点击发送，此时应该弹起浮窗，同时因为键盘和输入框还在弹起状态，那么气泡出现后也应该被顶起来，现在这种状态下气泡还是我输入框遮挡的，这暴露了一个问题，我们只是在某些条件下做了这件事情，而不是把这不遮挡，被顶起来的逻辑变成一个非常强硬的规则，在任何情况下都应该输入框把气泡顶起，气泡的空间就不应该能够走道输入框下方。

我研究了一下怎么修复，最好的方式是如下这种，你需要评估然后如果合理，就按照这种方案修复，确保任何情况下都不被遮挡。
我先直接给一个结论：
**“输入框永远不遮挡气泡”更适合被抽象成一种「布局规则/布局行为能力（Layout Behavior / Layout Rule）」**，而不是“输入框功能”或“列表功能”。在 Swift（UIKit）里，比较自然的落点是一个 **独立的 layout coordinator / behavior 对象 + 协议能力**。

下面给一个比较具体、能落到代码层面的抽象方式，你可以按自己工程里的“能力”命名规范去改名字。

---

## 1. 把它当成「聊天视口布局能力」而不是“某个控件的逻辑”

这个规则的本质是：

> **保证“可见对话区域（viewport）”的底边 = 输入框顶部**
> （即：通过调整 `contentInset`，保证气泡不被输入框挡住）

所以它更像是对「聊天视口（message list）」的一个**强布局不变量**，可以抽象成：

* `ConversationViewportLayoutCapability`
* 或中文语义：**`气泡可见性布局能力` / `聊天视口保护能力`**
* 职责：只关心“给我一个输入框的实时位置/底边高度，我负责把列表/气泡区域调好”。

---

## 2. 协议层面：定义一类能力

比如定义一个协议，表示“能根据输入框位置调整自身布局”的能力：

```swift
protocol InputOverlayAvoidingLayout {
    /// 当输入框实际位置变化时调用
    func updateLayoutForInputDrawer(bottomSpaceFromScreen: CGFloat)
}
```

在你的场景里：

* 这个协议的实现者是：**承载气泡的视图 / 列表控制器**（比如 `ChatOverlayManager` / `ChatViewController`）
* 它内部会用 `bottomSpaceFromScreen` 去算 `contentInset.bottom`、`scrollIndicatorInsets.bottom` 等。

然后给你现在的 `ChatOverlayManager` 加一个能力实现：

```swift
final class ChatOverlayManager: UIViewController, InputOverlayAvoidingLayout {
    
    func updateLayoutForInputDrawer(bottomSpaceFromScreen: CGFloat) {
        adjustExpandedContentInset(for: bottomSpaceFromScreen)
    }

    private func adjustExpandedContentInset(for bottomSpace: CGFloat) {
        // 这里就是你现在已有的逻辑：
        // 根据 bottomSpace 调整 collectionView / tableView 的 contentInset
    }
}
```

> 这样，**“永不遮挡气泡”就变成了一种 Layout 能力**，而不是散落在各处的 if/else。

---

## 3. 再配一个「协调者」：监听输入框 → 派发给能力对象

你现在已经有 `InputDrawerState.shared.latestActualBottomSpace` + 通知，这里可以进一步抽象成一个专门的 coordinator/capability：

```swift
protocol InputDrawerPositionObservable: AnyObject {
    var latestBottomSpace: CGFloat { get }
    var onBottomSpaceChanged: ((CGFloat) -> Void)? { get set }
}

/// 职责：把“输入框实时位置”转成对“布局能力”的统一回调
final class InputDrawerLayoutCoordinator {
    
    private weak var layout: InputOverlayAvoidingLayout?
    private weak var positionObservable: InputDrawerPositionObservable?

    init(layout: InputOverlayAvoidingLayout,
         positionObservable: InputDrawerPositionObservable) {
        self.layout = layout
        self.positionObservable = positionObservable

        positionObservable.onBottomSpaceChanged = { [weak self] bottomSpace in
            self?.layout?.updateLayoutForInputDrawer(bottomSpaceFromScreen: bottomSpace)
        }
    }

    /// 可在首次展开 / viewDidAppear 时手动强制对齐一次
    func syncInitialLayout() {
        guard let bottom = positionObservable?.latestBottomSpace else { return }
        layout?.updateLayoutForInputDrawer(bottomSpaceFromScreen: bottom)
    }
}
```

在 `ChatOverlayManager.viewDidAppear` 里，你现在做的事情就可以变成：

```swift
class ChatOverlayManager: UIViewController, InputOverlayAvoidingLayout {

    private lazy var inputDrawerLayoutCoordinator = InputDrawerLayoutCoordinator(
        layout: self,
        positionObservable: InputDrawerState.shared  // 让它 conform InputDrawerPositionObservable
    )

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)

        // 展开态时做一次强规则同步
        if currentState == .expanded {
            inputDrawerLayoutCoordinator.syncInitialLayout()
        }
    }

    func updateForState(_ state: State) {
        // 你已有的逻辑...
        if state == .expanded {
            // 展开分支逻辑完毕后，强制再对齐一次
            inputDrawerLayoutCoordinator.syncInitialLayout()
        }
    }

    // MARK: - InputOverlayAvoidingLayout

    func updateLayoutForInputDrawer(bottomSpaceFromScreen: CGFloat) {
        adjustExpandedContentInset(for: bottomSpaceFromScreen)
    }
}
```

> 这里 `InputDrawerState.shared` 只负责“暴露输入框位置 + 变化事件”，
> 真正“如何保证不遮挡气泡”由 `InputOverlayAvoidingLayout` 能力实现。

---

## 4. 从“能力类型”角度总结一下

如果你们文档里在分类“能力类型”，我会这样归类：

1. **能力归属：UI 布局能力（Layout Capability）**

   * 不是业务能力，也不是输入框功能，而是**聊天视口的布局不变量**。
2. **侧重点：强规则 / 不变量**

   * 这条规则“不论键盘、姿态、窗口出现时机如何，只要处于展开态，就必须满足”。
   * 在抽象上可以归为「强布局规则能力（Strong Layout Invariant）」。
3. **具象化为 Swift 类型**

   * 能力协议：`InputOverlayAvoidingLayout`（或你们约定的命名）
   * 协调者：`InputDrawerLayoutCoordinator`
   * 状态源：`InputDrawerPositionObservable`（`InputDrawerState` conform）
   * 具体承载者：`ChatOverlayManager`（或具体的聊天 VC）

---

如果你愿意，我也可以帮你**按照你们现有“任务文档的能力分类规则”给出一套命名方案**（比如“#布局能力/#强规则能力/#视口能力”等），你可以直接复制到文档里用。

#任务6

