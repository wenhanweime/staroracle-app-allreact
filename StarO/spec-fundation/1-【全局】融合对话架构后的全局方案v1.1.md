这是一份非常清晰的请求。你提供的这份《集星问问 (StarO) 后端技术规格说明书》其实已经是对之前讨论内容的**高度提炼和最终决策**。

针对你提出的“这两份方案（NextChat 纯客户端方案 vs StarO 云原生方案）都在说什么，有没有冲突，能兼容吗”这个问题，以及你要求的“唯一真理源”文档，我将分两部分来回答：

### 第一部分：方案对比与冲突分析

**1. 都在说什么？**

- **NextChat (旧方案/参考方案)**：
    - **核心逻辑**：完全依赖前端（浏览器/手机）。计算 Token、压缩记忆、存储对话记录全在本地。
    - **优势**：隐私性高，服务器成本几乎为零。
    - **劣势**：**数据孤岛**（换手机丢记录）、无法实现全网排行榜/社交、复杂的 Token 计算耗费手机电量。
- **StarO (新方案/当前规格书)**：
    - **核心逻辑**：**“瘦客户端”**。手机只负责显示，所有大脑（思考、记忆、演化）都在 Supabase 云端。
    - **优势**：**多端同步**、数据即资产（星星可以永存）、防作弊（后端控制演化）、手机极度省电。
    - **劣势**：有服务器成本（Supabase Edge Function 调用费）。

**2. 有没有冲突？**

- **架构冲突**：**有**。你不能既让客户端全权管理数据库（NextChat 模式），又想在服务端控制核心资产（StarO 模式）。**数据主权必须二选一**。在 StarO 中，主权属于后端数据库。
- **逻辑冲突**：**无**。NextChat 的优秀算法（如“滑动窗口截断”、“长短期记忆摘要”）并非架构，而是**策略**。这些策略完全可以从前端代码“搬运”到后端 Edge Function 中执行。

**3. 能兼容吗？**

- **完美兼容（以“移植”的方式）**：目前的 StarO 方案，实际上就是把 NextChat 的**大脑（逻辑层）挖出来，移植到了 Supabase 的 Edge Function 里，同时加上了云端记忆（数据库层）**。
- **结论**：这份规格书是 NextChat 逻辑的**云端进化版**，不存在不可调和的矛盾，只有代码执行位置的迁移。

---

### 第二部分：项目唯一真理源 (Source of Truth)

基于你提供的规格书框架，我填充了**具体的落地代码（SQL & TypeScript）**，使其成为一份既能指导架构，又能直接复制粘贴开发的**执行级文档**。

---

# 🌌 集星问问 (StarO) - 全栈技术规格说明书 (Source of Truth)

|属性|内容|
|---|---|
|**版本**|v1.0 Final|
|**基建**|Supabase (Postgres + Edge Functions + Auth + Vector)|
|**客户端**|iOS (SwiftUI + Metal)|
|**核心理念**|Logic in Cloud, Rendering on Edge (云端定逻辑，终端做渲染)|

---

## 1. 核心架构与数据流 (Architecture & Data Flow)

本系统采用 **Serverless 架构**，彻底剥离客户端的业务逻辑，确保数据一致性与资产安全性。

### 1.1 核心数据流转图

1. **身份层 (Identity)**：App 启动 -> 匿名/邮箱登录 -> 触发 Postgres Trigger -> 自动生成 `profiles` (含唯一的 `galaxy_seed`)。
2. **交互层 (Interaction)**：用户发消息 -> Swift 调用 Edge Function (`chat-send`) -> 后端计算 Token/摘要 -> 流式返回。
3. **资产层 (Assets)**：对话结束/深度达标 -> 触发 Edge Function (`star-cast`) -> LLM 提取结构化数据 -> 存入 `stars` -> Swift 渲染 3D 星星。

---

## 2. 数据库详细设计 (Database Implementation)

**原则**：所有表必须启用 RLS (Row Level Security)。

### 2.1 基础设置 (Extensions)

```sql
-- 必须先执行
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS vector; -- 为未来 RAG/搜索做准备

```

### 2.2 用户档案表 (`profiles`)

**核心逻辑**：用户的“基因”在注册瞬间由数据库决定，而非客户端生成。

```sql
CREATE TABLE public.profiles (
    id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
    email TEXT,
    -- [核心] 银河种子，范围 0-MaxInt，决定 Metal 渲染的所有随机数
    galaxy_seed BIGINT NOT NULL,
    -- [视觉] 显性基因：{"arm_count": 5, "core_color": "#FF5733"}
    galaxy_genes JSONB NOT NULL DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users view own profile" ON profiles FOR SELECT USING (auth.uid() = id);

```

### 2.3 触发器：自动生成基因 (Trigger)

**说明**：这是“后端定基因”的强制执行手段。

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, galaxy_seed, galaxy_genes)
  VALUES (
    new.id,
    new.email,
    floor(random() * 9000000000000000000)::BIGINT, -- 生成巨型随机种子
    jsonb_build_object(
      'arm_count', floor(random() * 4 + 3)::INT, -- 3-7 条旋臂
      'core_density', trunc((0.5 + random() * 0.5)::numeric, 2)
    )
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

```

### 2.4 会话容器表 (`chats`)

**核心逻辑**：移植 NextChat 的会话配置与长短期记忆指针。

```sql
CREATE TABLE public.chats (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES auth.users NOT NULL,
    title TEXT DEFAULT 'New Chat',

    -- [移植 NextChat] 长期记忆摘要
    memory_prompt TEXT DEFAULT '',
    -- [移植 NextChat] 上次摘要处理到的消息索引
    last_summarize_index INT4 DEFAULT 0,
    -- [移植 NextChat] 模型配置 (Temperature, HistoryCount)
    config JSONB DEFAULT '{"temperature": 0.6, "history_count": 20}'::JSONB,

    -- [StarO 独有] 演化指标
    total_reflection_pairs INT4 DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- RLS
ALTER TABLE public.chats ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users manage own chats" ON chats FOR ALL USING (auth.uid() = user_id);

```

### 2.5 消息流水表 (`messages`)

**核心逻辑**：存储用于“铸星”的原材料。

```sql
CREATE TABLE public.messages (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    chat_id UUID REFERENCES public.chats ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users NOT NULL, -- 冗余字段，方便 RLS
    role TEXT CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,

    -- [优化] 预计算 Token，避免运行时重复计算
    token_count INT4 DEFAULT 0,

    -- [元数据] 思考链、引用来源
    annotations JSONB,

    created_at TIMESTAMPTZ DEFAULT now()
);

-- RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users manage own messages" ON messages FOR ALL USING (auth.uid() = user_id);

```

### 2.6 星星资产表 (`stars`)

**核心逻辑**：将非结构化的对话（Message）转化为结构化的资产（Star）。

```sql
CREATE TABLE public.stars (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES auth.users NOT NULL,
    chat_id UUID REFERENCES public.chats,

    -- [内容]
    user_reflection TEXT, -- 用户核心感悟
    ai_reflection_phrase TEXT, -- AI 赠语 (金句)
    summary TEXT, -- 对话摘要

    -- [视觉] 后端计算出的 3D 坐标，客户端直接渲染
    coord_x FLOAT8 NOT NULL,
    coord_y FLOAT8 NOT NULL,
    coord_z FLOAT8 NOT NULL,
    star_arm_assignment TEXT, -- 所属旋臂

    -- [交互]
    primary_emotion TEXT, -- 情感基调
    haptic_pattern_id TEXT, -- 震动模式 ID (iOS 对应)

    -- [演化]
    evolution_status TEXT DEFAULT 'Nova', -- Nova, Star, Supernova

    created_at TIMESTAMPTZ DEFAULT now()
);

-- RLS
ALTER TABLE public.stars ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users manage own stars" ON stars FOR ALL USING (auth.uid() = user_id);

```

---

## 3. 服务端逻辑规范 (Edge Functions)

所有业务逻辑不再由 Swift 处理，而是通过 REST API 调用 Supabase Edge Functions。

### 3.1 核心对话接口 (`chat-send`)

**路径**: `/api/chat-send`**职责**: 上下文组装、LLM 推理、记忆压缩。

### 代码逻辑伪代码 (TypeScript)

```tsx
// 1. 接收 Request
const { chat_id, message } = req.body;

// 2. 数据库读取 (并行)
const [chatConfig, historyMessages] = await Promise.all([
  supabase.from('chats').select('*').eq('id', chat_id).single(),
  supabase.from('messages').select('*').eq('chat_id', chat_id).order('created_at', { ascending: false }).limit(20)
]);

// 3. 构建上下文 (Context Builder - 移植 NextChat 逻辑)
let context = [];
// A. System Prompt
context.push({ role: 'system', content: chatConfig.config.system_prompt });
// B. Long Term Memory
if (chatConfig.memory_prompt) {
  context.push({ role: 'system', content: `之前对话摘要: ${chatConfig.memory_prompt}` });
}
// C. History (带 Token 截断逻辑)
let tokenSum = 0;
const MAX_TOKENS = 4000;
for (let msg of historyMessages) {
  if (tokenSum + msg.token_count > MAX_TOKENS) break;
  context.unshift({ role: msg.role, content: msg.content }); // 倒序插入
  tokenSum += msg.token_count;
}
// D. Current Message
context.push({ role: 'user', content: message });

// 4. 请求 OpenAI (Streaming)
const stream = await openai.chat.completions.create({ stream: true, messages: context, ... });

// 5. 返回流给客户端 (不等待 DB 操作)
return new Response(stream);

// 6. 后台异步操作 (EdgeRuntime.waitUntil)
EdgeRuntime.waitUntil(async () => {
  // A. 存新消息
  await supabase.from('messages').insert([...]);

  // B. 判断是否需要摘要 (移植 NextChat summarizeSession)
  if (newMessagesCount > 10) {
    const summary = await generateSummary(historyMessages);
    await supabase.from('chats').update({ memory_prompt: summary }).eq('id', chat_id);
  }

  // C. 铸星判断
  if (isDeepConversation(historyMessages)) {
    // 触发铸星逻辑
    await castStar(chat_id, user_id, historyMessages);
  }
});

```

### 3.2 铸星接口 (`star-cast`)

**职责**: 将对话变为星星。这是一个纯后端计算过程。

1. **输入**: 最近的对话历史。
2. **LLM 分析**: 调用 JSON Mode，要求返回 `{ "emotion": "hopeful", "summary": "...", "tags": ["love", "loss"] }`。
3. **坐标计算 (核心算法)**:
    - 读取 `profiles.galaxy_seed`。
    - 结合 Hash 算法与随机数，计算唯一的 `(x, y, z)`。
    - 确保星星分布在螺旋臂上（使用对数螺旋线公式）。
4. **存储**: 写入 `stars` 表。

---

## 4. 客户端开发规范 (Client Spec - iOS)

客户端极度简化，遵循 **MVVM** 模式。

### 4.1 职责边界

- ❌ **禁止**: 在客户端计算 Token。
- ❌ **禁止**: 在客户端直接拼接 Prompt。
- ❌ **禁止**: 在客户端决定星星坐标。
- ✅ **允许**: 从 `stars` 表拉取数据。
- ✅ **允许**: 监听 Server-Sent Events (SSE) 渲染打字机效果。
- ✅ **允许**: 使用 Metal 渲染 3D 场景。

### 4.2 关键数据获取

- **App 启动**: `await supabase.from('profiles').select('galaxy_seed')` -> 初始化 Metal 随机数生成器。
- **星空视图**: `await supabase.from('stars').select('*')` -> 遍历并在 3D 空间中画点。

---

## 5. 安全与权限 (Security)

1. **API Key**: 客户端仅持有 `SUPABASE_ANON_KEY`。
2. **OpenAI Key**: 仅存储在 Supabase Edge Function 的环境变量中，**严禁**下发到客户端。
3. **RLS**: 严格执行“只能看自己的数据”策略。

---

这份文档现在是你的**项目宪法**。它融合了 NextChat 的对话智能策略和 Supabase 的云原生架构优势。开发时，请严格对照此文档的 Schema 和 API 逻辑进行编码。